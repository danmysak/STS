# STS

Це — (офлайнова) система оцінювання програм, написаних на C++, Python, Java тощо, відповідно до кількості пройдених ними тестів із наперед заданого набору. Систему можна використовувати у спортивному програмуванні або для загального тестування простих програм.

Систему використовували на київських міських учнівських олімпіадах з інформатики, олімпіадах з інформатики Солом’янського району, а також для підготовки інших змагань.


## Встановлення

Система працює під управлінням операційної системи Windows та не потребує встановлення. Просто запустіть файл `STS.exe` із довільної директорії. Завантажити бінарні файли можна [зі сторінки релізів](https://github.com/danmysak/STS/releases/).


## Робоча тека

Робоча тека повинна містити набір піддиректорій, у яких зберігаються файли з вихідними кодами програм. Кожна така піддиректорія відповідає одному учаснику та може містити кілька програм і опціонально файл `contest.txt` з інформацією про учасника. Очікуваний формат файлу `contest.txt` (по рядках):

1) повне ім’я учасника;
2) район;
3) повна назва навчального закладу;
4) клас;
5) ідентифікатор робочого місця (номер комп’ютера);
6) контактна інформація;
7) скорочена назва навчального закладу.

Замість тих чи інших даних можна залишити порожній рядок; тоді їх не буде вказано і в підсумковій таблиці. Якщо файл відсутній, замість імені учасника в результатах відображатиметься назва його директорії.


## Директорія з тестами

Директорія з тестами повинна містити тести до всіх задач у довільному форматі, а також файл чи кілька файлів з описом тестів. Детальніше про формат таких файлів та імен тестів див. нижче.


## Розширення та компілятори

Додайте одне або кілька розширень для дозволених мов програмування. Для кожного розширення визначте один або кілька компіляторів чи інтерпретаторів. Використовуйте, коли треба, такі змінні: `%file` — шлях до файлу з програмою, `%exe` — файл, у який потрібно скомпілювати програму, `%task` — поточна задача. Якщо одному розширенню файлів відповідає два чи більше компіляторів, для їх розрізнення слід використати коментарі-ідентифікатори, які учасники мають проставляти у першому рядку своїх програм. У разі, якщо програма містить неправильний ідентифікатор, для запуску буде використано перший компілятор (або інтерпретатор) зі списку, але у CSV-файлі результатів міститиметься відповідне попередження.

**Приклади** налаштувань:

Розширення `cpp`, компілятор «GCC»:
- шлях до компілятора: `C:\Program Files\CodeBlocks\MinGW\bin\g++.exe`
- параметри компіляції: `-O2 -static -lm %file -o %exe`

Розширення `pas`, компілятор «FP» (Free Pascal):
- шлях до компілятора: `C:\FPC\3.0.0\bin\i386-win32\fpc.exe`
- параметри компіляції: `-O -O2 %file`

Розширення py, компілятор «Python 3»:
- шлях до інтерпретатора: `C:\Python34\python.exe`
- параметри інтерпретації: `%file`
- коментар-ідентифікатор: `""" Python 3 """`

Розширення `py`, компілятор «Python 2»:
- шлях до інтерпретатора: `C:\Python27\python.exe`
- параметри інтерпретації: `%file`
- коментар-ідентифікатор: `""" Python 2 """`

Розширення `java`, компілятор «Java»:
- шлях до компілятора: `C:\Program Files\Java\jdk1.8.0_111\bin\javac.exe`
- параметри компіляції: `%file`
- шлях до інтерпретатора: `C:\Program Files\Java\jre1.8.0_111\bin\java.exe`
- параметри інтерпретації: `-client -Xss256m -Xmx2048m %task`


## Назви задач та ознака кінця рядка

Задайте назви задач (скорочені англійські — не українські), а також коефіцієнт, на який множитимуться результати програм, що не створюють у кінці вихідного файлу новий рядок або інакше не дотримуються формату whitespace у вихідному файлі. Якщо відповідне налаштування скинути, будь-яке виведення, крім побайтово ідентичного, розцінюватиметься як помилкове.


## Описовий файл тестів

Описовий файл тестів до задачі має такий формат:
- у першому рядку обмеження на час у мілісекундах на витрачений процесорний час та опціонально обмеження на пам’ять у кілобайтах;
- у наступних рядках можна задавати номер тесту або проміжок номерів (користуючись комами та/або дефісами) та через пробіл вартість тестів у відповідній групі (ціле число);
- далі опціонально такі параметри (назва параметра і через двокрапку та пробіл числове значення):
  - `extraTime` — час у мілісекундах, який система вичекає додатково до обмеження на час перед тим, як завершити виконання програми (це має сенс, бо витрачений процесорний час усе ще може виявитися меншим за обмеження). Якщо не задано, система вважає `extraTime` рівним половині обмеження на час. 
  - `interactive` — якщо задано і не дорівнює нулю, то час виконання засікатиметься з моменту, коли в потік `stderr` буде виведено спеціальний сигнал — символ `0`, а припинить засікатися, коли в той же потік буде виведено символ `1`.

**Приклад**, що задає обмеження в 1 секунду та 256 мегабайтів та вартість перших 10 тестів по 4 бали, а решти 10 — по 6 балів; додатковий час на запуск програми — 800 мс:

```
1000 262144
1-10 4
11-20 6

extraTime: 800
```

Описовий файл може бути спільним для всіх задач або для різних задач різним (наприклад, якщо різною є кількість тестів у різних задачах). У такому випадку, щоб указати шлях до файлу з описом тестів, слід скористатися змінною `%task`, що задає назву задачі.


## Чекери

Якщо посимвольного порівняння (можливо, з урахуванням різного whitespace) між отриманим та еталонним вихідними файлами не вистачає, можна дописати спеціальний чекер. Чекер — `dll`-файл, що лежить у папці з тестами, називається `check.dll` та експортує функцію такої сигнатури:

```
function check_output(input, output, prompt: pchar; points: integer): double;
```

`input`, `output`, `prompt` — шляхи до вхідного, вихідного та еталонного файлів відповідно; `points` — ціна тесту. Функція має повернути кількість балів, які слід нарахувати за отриману відповідь — довільне число від 0 до `points`.

Разом із STS у репозиторії є простий приклад чекера, а також адаптери під STS чекерів від інших систем перевірки: ejudge та kgrader. Щоб їх використати, розташуйте у папці з тестами файл під назвою `check.dll`, а також оригінальний чекер відповідної системи перевірки під назвою `check.exe`.


## Вхідні та вихідні файли

У лівій частині інтерфейсу потрібно вказати, де розташовано вхідні та еталони вихідних файлів у каталозі з тестами. У правій частині — як називаються вхідний та вихідний файли з погляду програми учасника.

**Приклад** заповнення відповідних полів:

| Тип     | Зліва              | Справа      |
|---------|--------------------|-------------|
| Вхідні  | `%task\%num:3.in`  | `%task.in`  |
| Вихідні | `%task\%num:3.ans` | `%task.out` |

Це означає, що в директорії з тестами тести до кожної задачі зберігаються в окремому каталозі, назва якого — це назва задачі, під іменами `001.in`/`001.ans`, `002.in`/`002.ans` і т. д. (зауважте, що число `3` після двокрапки визначає, що номер тесту потрібно доповнити нулями зліва, поки число не стане трицифровим). Назви вхідного та вихідного файлів для програми виглядають у поданому прикладі як назва задачі з розширеннями `in` та `out` відповідно.

Якщо залишити поля справа (або одне з них) порожніми, система припускатиме, що програма працює зі стандартним уведенням/виведенням.


## Результати перевірки

Після запуску перевірки система показуватиме її прогрес у режимі реального часу. По завершенні буде згенеровано такі файли:
- CSV-файл із таблицею результатів, прив’язаних до ідентифікаційних даних учасників.
- Детальну інтерактивну таблицю з можливістю перегляду результатів окремих тестів, виведення програм учасників та різниці з еталонним виведенням. Таблиця доступна для перегляду з інтерфейсу STS.
- У каталогах учасників буде створено текстові файли з деталізованими результатами перевірки їхніх програм, а в папці `!output` збережено створені цими програмами вихідні файли.